package com.nsalazar.quicktask.task.infrastructure.database;

import com.nsalazar.quicktask.task.domain.Task;
import com.nsalazar.quicktask.task.domain.repository.ITaskRepository;
import com.nsalazar.quicktask.task.infrastructure.database.entity.TaskEntity;
import com.nsalazar.quicktask.task.infrastructure.database.mapper.ITaskEntityMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repository implementation for Task entities.
 *
 * <p>Provides data access operations for tasks using Spring Data JPA. This class acts as a bridge
 * between the domain layer and the persistence layer, converting between domain objects ({@link Task})
 * and database entities ({@link TaskEntity}).
 *
 * <p><strong>Design Pattern:</strong>
 * This class implements the Repository pattern, which mediates between the domain layer and
 * the database mapping layer. It provides an object-oriented view of the database and shields
 * the service layer from database implementation details.
 *
 * <p><strong>Key Responsibilities:</strong>
 * <ul>
 *   <li>Delegate database operations to Spring Data JPA ({@link IJPATaskRepository})</li>
 *   <li>Convert TaskEntity persistence objects to Task domain objects and vice versa</li>
 *   <li>Maintain the separation between domain layer and persistence layer</li>
 *   <li>Provide a clean interface for the service layer to access task data</li>
 * </ul>
 *
 * <p><strong>Mapping Flow:</strong>
 * <ul>
 *   <li><strong>Read Operations:</strong> Database → TaskEntity → Task domain object</li>
 *   <li><strong>Write Operations:</strong> Task domain object → TaskEntity → Database</li>
 *   <li>Mapping is performed by {@link ITaskEntityMapper} to ensure consistency</li>
 * </ul>
 *
 * <p><strong>Dependency Injection:</strong>
 * Uses Lombok's {@code @RequiredArgsConstructor} annotation to generate a constructor
 * that accepts all final fields as parameters. Spring automatically injects:
 * <ul>
 *   <li>{@code IJPATaskRepository jpaTaskRepository} - Spring Data JPA repository</li>
 *   <li>{@code ITaskEntityMapper taskEntityMapper} - MapStruct-generated mapper bean</li>
 * </ul>
 *
 * <p><strong>Transaction Context:</strong>
 * Transaction management is handled by the service layer. This repository operates within
 * the transactional context provided by the calling service method. All database operations
 * are performed within an existing transaction.
 *
 * <p><strong>Architecture Layer:</strong>
 * This class is part of the infrastructure layer and should only be used by the service layer.
 * The domain layer should depend on the {@link ITaskRepository} interface, not this implementation.
 *
 * @author nsalazar
 * @see ITaskRepository
 * @see IJPATaskRepository
 * @see ITaskEntityMapper
 * @see Task
 * @see TaskEntity
 */
@Repository
@RequiredArgsConstructor
public class TaskRepository implements ITaskRepository {

    /**
     * Spring Data JPA repository for direct database operations on TaskEntity.
     *
     * <p><strong>Responsibilities:</strong>
     * <ul>
     *   <li>Provides CRUD operations (Create, Read, Update, Delete)</li>
     *   <li>Executes JPA queries and custom database queries</li>
     *   <li>Manages database transactions at the persistence layer</li>
     *   <li>Returns TaskEntity objects that map to database rows</li>
     * </ul>
     *
     * <p><strong>Used By Methods:</strong>
     * <ul>
     *   <li>{@link #findAll(Pageable)} - for fetching paginated results</li>
     *   <li>{@link #findById(UUID)} - for fetching a single task by primary key</li>
     *   <li>{@link #save(Task)} - for inserting or updating tasks</li>
     *   <li>{@link #delete(UUID)} - for deleting a task by ID</li>
     *   <li>{@link #existsById(UUID)} - for checking task existence</li>
     * </ul>
     */
    private final IJPATaskRepository jpaTaskRepository;

    /**
     * Mapper for converting between domain Task objects and database TaskEntity objects.
     *
     * <p><strong>Responsibilities:</strong>
     * <ul>
     *   <li>Converts TaskEntity persistence objects to Task domain objects</li>
     *   <li>Converts Task domain objects to TaskEntity persistence objects</li>
     *   <li>Ensures consistent mapping across all repository operations</li>
     *   <li>Maintains separation of concerns between domain and persistence layers</li>
     * </ul>
     *
     * <p><strong>Type-Safe Mapping:</strong>
     * The mapper is generated by MapStruct at compile-time, ensuring type safety
     * and eliminating the need for runtime reflection or manual mapping code.
     *
     * <p><strong>Used By Methods:</strong>
     * <ul>
     *   <li>{@link #findAll(Pageable)} - maps each TaskEntity to Task in the Page</li>
     *   <li>{@link #findById(UUID)} - maps the Optional TaskEntity to Optional Task</li>
     *   <li>{@link #save(Task)} - bidirectional mapping for save operations</li>
     * </ul>
     */
    private final ITaskEntityMapper taskEntityMapper;

    /**
     * Retrieves a paginated list of all tasks from the database.
     *
     * <p><strong>Operation Flow:</strong>
     * <ol>
     *   <li>Calls {@code jpaTaskRepository.findAll(pageable)} to fetch a Page of TaskEntity objects</li>
     *   <li>Maps each TaskEntity to a Task domain object using the mapper</li>
     *   <li>Returns a new Page containing the mapped Task objects</li>
     * </ol>
     *
     * <p><strong>Pagination & Sorting:</strong>
     * The pageable parameter controls:
     * <ul>
     *   <li>Page number (zero-indexed) - which page of results to return</li>
     *   <li>Page size - maximum number of tasks per page</li>
     *   <li>Sorting - field names and direction (ascending/descending)</li>
     * </ul>
     *
     * <p><strong>Return Value:</strong>
     * The returned Page contains domain Task objects, not persistence entities.
     * Page metadata is preserved from the underlying JPA query result.
     *
     * <p><strong>Performance Characteristics:</strong>
     * <ul>
     *   <li>Uses database LIMIT/OFFSET for efficient pagination</li>
     *   <li>Only fetches the requested page, not all tasks</li>
     *   <li>Mapping is performed in-memory after database retrieval</li>
     * </ul>
     *
     * <p><strong>Example Usage:</strong>
     * <pre>
     * Pageable pageable = PageRequest.of(0, 20, Sort.by("createdAt").descending());
     * Page&lt;Task&gt; tasksPage = repository.findAll(pageable);
     * </pre>
     *
     * @param pageable pagination information including page number, size, and sorting criteria.
     *                 Must not be null.
     * @return a {@link Page} of domain {@link Task} objects with the specified pagination.
     *         Contains the tasks for the requested page and metadata about total pages and size.
     * @throws IllegalArgumentException if pageable is null
     *
     * @see Page
     * @see Pageable
     */
    @Override
    public Page<Task> findAll(Pageable pageable) {
        return jpaTaskRepository.findAll(pageable)
                .map(taskEntityMapper::toTask);
    }

    /**
     * Retrieves a single task by its unique identifier.
     *
     * <p><strong>Operation Flow:</strong>
     * <ol>
     *   <li>Calls {@code jpaTaskRepository.findById(id)} to search by primary key</li>
     *   <li>If found, maps the TaskEntity to a Task domain object</li>
     *   <li>Returns an Optional containing the Task, or empty Optional if not found</li>
     * </ol>
     *
     * <p><strong>Query Type:</strong>
     * This is a primary key lookup - the most efficient database query type.
     * The database returns at most one row.
     *
     * <p><strong>Return Value:</strong>
     * <ul>
     *   <li>If task exists: Optional containing the Task domain object</li>
     *   <li>If task not found: Empty Optional</li>
     * </ul>
     *
     * <p><strong>Handling the Result:</strong>
     * <pre>
     * Optional&lt;Task&gt; task = repository.findById(id);
     * if (task.isPresent()) {
     *     Task foundTask = task.get();
     *     // Use the task...
     * } else {
     *     // Task not found - handle error
     * }
     * </pre>
     *
     * <p><strong>Performance:</strong>
     * This is one of the fastest database operations, using the primary key (UUID) for lookup.
     * Time complexity is O(1) on average.
     *
     * <p><strong>Common Use Cases:</strong>
     * <ul>
     *   <li>Retrieving a specific task for display or editing</li>
     *   <li>Validating that a task exists before updating or deleting</li>
     *   <li>Fetching a task by ID received from an API request</li>
     * </ul>
     *
     * @param id the UUID of the task to retrieve. Must not be null.
     * @return an {@link Optional} containing the {@link Task} if found, or empty Optional if not found.
     *         Never returns null; returns an empty Optional when no task exists with the given ID.
     * @throws IllegalArgumentException if id is null
     *
     * @see Optional
     * @see UUID
     */
    @Override
    public Optional<Task> findById(UUID id) {
        return jpaTaskRepository.findById(id)
                .map(taskEntityMapper::toTask);
    }

    /**
     * Saves a new task or updates an existing task in the database.
     *
     * <p><strong>Operation Flow:</strong>
     * <ol>
     *   <li>Converts the Task domain object to a TaskEntity using the mapper</li>
     *   <li>Calls {@code jpaTaskRepository.save(entity)} for persistence</li>
     *   <li>Converts the returned TaskEntity back to a Task domain object</li>
     *   <li>Returns the Task with all database-generated values populated</li>
     * </ol>
     *
     * <p><strong>Create vs Update Logic:</strong>
     * <ul>
     *   <li><strong>Create (INSERT):</strong> If task.id is null, database generates a new UUID</li>
     *   <li><strong>Update (UPDATE):</strong> If task.id exists, the matching row is updated</li>
     *   <li>JPA Spring Data automatically determines whether to INSERT or UPDATE</li>
     * </ul>
     *
     * <p><strong>Database-Generated Values:</strong>
     * The following fields are populated by the database during save:
     * <ul>
     *   <li>{@code id} - Auto-generated UUID for new tasks (GenerationType.UUID)</li>
     *   <li>{@code createdAt} - Set by service layer before save</li>
     *   <li>{@code completed} - Defaults to FALSE if not explicitly set</li>
     * </ul>
     *
     * <p><strong>Mapping Bidirectionality:</strong>
     * <ul>
     *   <li>Input mapping: Task domain object → TaskEntity persistence object</li>
     *   <li>Output mapping: Saved TaskEntity → Task domain object</li>
     *   <li>Ensures the returned Task object is fresh from the database</li>
     * </ul>
     *
     * <p><strong>Transaction Context:</strong>
     * This method must be called within a transactional context provided by the service layer.
     * Changes are committed when the transaction completes.
     *
     * <p><strong>Example Usage - Create:</strong>
     * <pre>
     * Task newTask = Task.builder()
     *     .title("Complete documentation")
     *     .description("Write API documentation")
     *     .completed(false)
     *     .createdAt(LocalDateTime.now())
     *     .build();
     * Task saved = repository.save(newTask);
     * // saved.getId() now contains the auto-generated UUID
     * </pre>
     *
     * <p><strong>Example Usage - Update:</strong>
     * <pre>
     * Task existingTask = // ... retrieved from database
     * existingTask.setTitle("Updated title");
     * existingTask.setUpdatedAt(LocalDateTime.now());
     * Task updated = repository.save(existingTask);
     * </pre>
     *
     * @param task the domain {@link Task} object to save. Must not be null.
     *             For new tasks, the id field should be null.
     *             For updates, the id field should match an existing task's ID.
     * @return the saved {@link Task} object as a domain object with any database-generated
     *         fields populated (id, timestamps, etc.). The returned object reflects the
     *         current state in the database.
     * @throws IllegalArgumentException if task is null
     *
     * @see Task
     * @see TaskEntity
     */
    @Override
    public Task save(Task task) {
        TaskEntity taskEntity = taskEntityMapper.toTaskEntity(task);
        TaskEntity savedEntity = jpaTaskRepository.save(taskEntity);
        return taskEntityMapper.toTask(savedEntity);
    }

    /**
     * Deletes a task from the database by its unique identifier.
     *
     * <p><strong>Operation Flow:</strong>
     * <ol>
     *   <li>Calls {@code jpaTaskRepository.deleteById(id)} to remove the task</li>
     *   <li>If the task exists, it is deleted from the database</li>
     *   <li>If the task does not exist, the operation completes without error (idempotent)</li>
     * </ol>
     *
     * <p><strong>Idempotent Behavior:</strong>
     * This operation is safe to call multiple times with the same ID. If the task
     * does not exist, no error is thrown. The method completes successfully either way.
     *
     * <p><strong>Permanent Operation:</strong>
     * <ul>
     *   <li>The deletion is permanent and cannot be undone</li>
     *   <li>All data associated with the task is removed from the database</li>
     *   <li>There is no automatic backup or soft-delete functionality</li>
     * </ul>
     *
     * <p><strong>Transaction Context:</strong>
     * This method must be called within a transactional context provided by the service layer.
     * The deletion is committed when the transaction completes.
     *
     * <p><strong>Cascade Behavior:</strong>
     * Currently, there are no foreign key relationships or cascading deletes configured.
     * If relationships are added in the future, cascade behavior should be carefully considered.
     *
     * <p><strong>Performance:</strong>
     * This is a primary key lookup followed by a delete operation.
     * Time complexity is O(1) on average with proper database indexing.
     *
     * <p><strong>Best Practices:</strong>
     * <ul>
     *   <li>Verify the task exists before attempting deletion if you need to know the result</li>
     *   <li>Consider using {@link #existsById(UUID)} first if you want to distinguish "not found" from success</li>
     *   <li>Ensure the service layer enforces any business rules before deleting</li>
     * </ul>
     *
     * <p><strong>Example Usage:</strong>
     * <pre>
     * UUID taskId = UUID.fromString("f47ac10b-58cc-4372-a567-0e02b2c3d479");
     * repository.delete(taskId); // Always succeeds, even if task doesn't exist
     * </pre>
     *
     * @param id the UUID of the task to delete. Must not be null.
     * @throws IllegalArgumentException if id is null
     *
     * @see UUID
     * @see #existsById(UUID)
     */
    @Override
    public void delete(UUID id) {
        jpaTaskRepository.deleteById(id);
    }

    /**
     * Checks whether a task with the specified ID exists in the database.
     *
     * <p><strong>Operation Flow:</strong>
     * <ol>
     *   <li>Calls {@code jpaTaskRepository.existsById(id)} to check existence</li>
     *   <li>The database performs an efficient existence check</li>
     *   <li>Returns true if the task exists, false otherwise</li>
     * </ol>
     *
     * <p><strong>Efficiency:</strong>
     * This operation is more efficient than {@link #findById(UUID)} when you only need to
     * know whether a task exists without needing to retrieve its data. The database typically
     * optimizes this to a simple COUNT or EXISTS query rather than fetching all columns.
     *
     * <p><strong>Return Value:</strong>
     * <ul>
     *   <li>{@code true} - A task with the specified ID exists in the database</li>
     *   <li>{@code false} - No task exists with the specified ID</li>
     * </ul>
     *
     * <p><strong>Performance Characteristics:</strong>
     * <ul>
     *   <li>Uses primary key lookup for efficiency</li>
     *   <li>Does not retrieve the full task data</li>
     *   <li>Time complexity is O(1) on average with proper indexing</li>
     *   <li>Minimal database I/O and network transfer</li>
     * </ul>
     *
     * <p><strong>Common Use Cases:</strong>
     * <ul>
     *   <li>Pre-check before attempting to update a task</li>
     *   <li>Pre-check before attempting to delete a task</li>
     *   <li>Validate that a task exists before performing business logic</li>
     *   <li>Implement guard clauses in service methods</li>
     * </ul>
     *
     * <p><strong>Defensive Programming Pattern:</strong>
     * <pre>
     * if (repository.existsById(id)) {
     *     repository.delete(id);
     *     // Log successful deletion
     * } else {
     *     throw new ResourceNotFoundException("Task not found with id: " + id);
     * }
     * </pre>
     *
     * <p><strong>Comparison with Other Methods:</strong>
     * <ul>
     *   <li>More efficient than: {@code findById(id).isPresent()}</li>
     *   <li>Less data retrieval than: {@code findById(id)}</li>
     *   <li>Simpler than: {@code findById(id).map(...)} for just checking existence</li>
     * </ul>
     *
     * @param id the UUID of the task to check for existence. Must not be null.
     * @return {@code true} if a task with the specified UUID exists in the database,
     *         {@code false} otherwise
     * @throws IllegalArgumentException if id is null
     *
     * @see UUID
     * @see #findById(UUID)
     */
    @Override
    public boolean existsById(UUID id) {
        return jpaTaskRepository.existsById(id);
    }

}
